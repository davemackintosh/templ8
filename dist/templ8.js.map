{"version":3,"sources":["../index.js"],"names":[],"mappings":"AAEA;;AAEA;;;;;;AACA,IAAM,YAAoB,8BAA1B;;AAEA;;;;;;;AAOA,SAAS,qBAAT,CAA+B,MAA/B,EAA8D;AAC5D,MAAM,MAAM,OAAO,MAAP,CAAc,IAAd,CAAZ;;AAEA,SACG,GADH,CACO;AAAA,WAAQ,KAAK,IAAL,EAAR;AAAA,GADP,EAEG,MAFH,CAEU;AAAA,WAAQ,QAAQ,KAAK,MAAL,GAAc,CAA9B;AAAA,GAFV,EAGG,OAHH,CAGW,UAAC,IAAD,EAAO,KAAP,EAAiB;AACxB;AACA,QAAI,QAAQ,CAAR,KAAc,CAAlB,EACE,IAAI,IAAJ,IAAY,OAAO,QAAQ,CAAf,CAAZ;AACH,GAPH;;AASA,SAAO,GAAP;AACD;;AAED,SAAS,wBAAT,CAAkC,MAAlC,EAA0D;AACxD,MAAM,QAAQ,OAAO,KAAP,CAAa,GAAb,CAAd;AACA,MAAM,MAAM,EAAZ;;AAEA,QAAM,OAAN,CAAc,iBAAS;AAAA,uBACA,MAAM,KAAN,CAAY,GAAZ,CADA;AAAA;AAAA,QACd,GADc;AAAA,QACT,KADS;;AAErB,QAAM,WAAW,IAAI,IAAJ,GAAW,OAAX,CAAmB,YAAnB,EAAiC,UAAC,OAAD,EAAU,MAAV;AAAA,aAAqB,OAAO,WAAP,EAArB;AAAA,KAAjC,CAAjB;AACA,QAAI,QAAJ,IAAgB,MAAM,IAAN,EAAhB;AACD,GAJD;;AAMA,SAAO,GAAP;AACD;;AAED;;;;;AAKA,SAAS,cAAT,CAAwB,KAAxB,EAA0E;AAAA,MAAnC,IAAmC,uEAApB,aAAoB;;AACxE,MAAM,SAAc;AAClB;AADkB,GAApB;;AAIA;;AALwE,8BAMhD;AACtB;AADsB,GAErB,SAFqB,CAEX,CAFW,EAER,MAAM,MAAN,IAAgB,MAAM,QAAN,CAAe,IAAf,IAAuB,CAAvB,GAA2B,CAA3C,CAFQ;;AAItB;AAJsB,GAKrB,KALqB,CAKf,sDALe;;AAOtB;AAPsB,GAQrB,MARqB,CAQd;AAAA,WAAQ,QAAQ,KAAK,IAAL,GAAY,MAAZ,GAAqB,CAArC;AAAA,GARc,CANgD;AAAA;AAAA,MAMjE,GANiE;AAAA,MAMzD,KANyD;;AAgBxE,MAAI,CAAC,GAAL,EACE,OAAO,MAAP;;AAEF;AACA,MAAI,SAAS,aAAb,EAA4B;AAC1B,WAAO,OAAP,GAAiB,IAAI,IAAJ,EAAjB;AACA,WAAO,QAAP,GAAkB,EAAlB;AACD;;AAED,SAAO,OAAP,GAAiB,GAAjB;;AAEA;AACA,MAAI,MAAM,MAAN,GAAe,CAAnB,EAAsB;AACpB,QAAM,kBAAkB,sBAAsB,KAAtB,CAAxB;;AAEA,QAAI,gBAAgB,KAApB,EAA2B;AACzB,aAAO,KAAP,GAAe,yBAAyB,gBAAgB,KAAzC,CAAf;AACA,aAAO,gBAAgB,KAAvB;AACD;;AAED,QAAI,OAAO,IAAP,CAAY,eAAZ,EAA6B,MAA7B,GAAsC,CAA1C,EACE,OAAO,KAAP,GAAe,eAAf;AACH;;AAED,SAAO,MAAP;AACD;;AAED,SAAS,cAAT,CAAwB,QAAxB,EAA+C;AAC7C;AACA,MAAI,MAAW,EAAf;AACA,MAAI,QAAQ,CAAZ;;AAEA;AACA,MAAI,gBAAJ;;AAEA;AACA,MAAM,OAAO,EAAb;;AAEA;AACA,SAAM,UAAU,UAAU,IAAV,CAAe,QAAf,CAAhB,EAA0C;AACxC,QAAM,QAAQ,QAAQ,CAAR,CAAd;AACA,QAAM,kBAAkB,KAAK,MAAL,GAAc,CAAd,GAAkB,KAAK,KAAK,MAAL,GAAc,CAAnB,EAAsB,QAAxC,GAAmD,IAA3E;;AAEA;AACA,QAAI,UAAU,CAAd,EAAiB;AACf,YAAM,eAAe,KAAf,EAAsB,aAAtB,CAAN;AACA,WAAK,IAAL,CAAU,GAAV;AACD;AACD;AAJA,SAKK,IAAI,CAAC,MAAM,UAAN,CAAiB,GAAjB,CAAD,IAA0B,CAAC,MAAM,QAAN,CAAe,GAAf,CAA/B,EAAoD;AACvD,YAAI,mBAAmB,MAAM,OAAN,CAAc,MAAd,EAAsB,EAAtB,MAA8B,EAArD,EACE,gBAAgB,IAAhB,CAAqB;AACnB,gBAAM,aADa;AAEnB,gBAAM,KAFa;AAGnB,mBAAS;AAHU,SAArB;AAKH;AACD;AACA;AACA;AAVK,WAWA,IAAI,CAAC,MAAM,UAAN,CAAiB,IAAjB,CAAD,IAA2B,CAAC,MAAM,QAAN,CAAe,IAAf,CAAhC,EAAsD;AACzD,cAAM,UAAU,eAAe,KAAf,EAAsB,aAAtB,CAAhB;AACA,cAAI,eAAJ,EACE,gBAAgB,IAAhB,CAAqB,OAArB;;AAEF,eAAK,IAAL,CAAU,OAAV;AACD;AACD;AACA;AARK,aASA;AACH,iBAAK,GAAL;AACD;;AAED;AACA;AACD;;AAED,MAAI,CAAC,IAAI,QAAL,IAAiB,IAAI,QAAJ,CAAa,MAAb,KAAwB,CAA7C,EACE,OAAO,IAAI,QAAX;;AAEF,SAAO,OAAO,WAAP,CAAmB,GAAnB,CAAP;AACD;;AAED;;;;;;;;;AASA,SAAS,MAAT,CAAgB,QAAhB,EAAwE;AAAA,oCAA5B,MAA4B;AAA5B,UAA4B;AAAA;;AACtE;AACA,MAAM,oBAAoB,SAAS,MAAT,CAAgB,UAAC,GAAD,EAAM,OAAN,EAAe,KAAf,EAAyB;AACjE,WAAO,OAAP;AACA,QAAI,OAAO,cAAP,CAAsB,KAAtB,CAAJ,EACE,OAAO,OAAO,KAAP,CAAP;;AAEF,WAAO,GAAP;AACD,GANyB,EAMvB,EANuB,CAA1B;;AAQA,MAAI,sBAAsB,EAA1B,EAA8B;AAC5B,UAAM,IAAI,KAAJ,CAAU,iJAAV,CAAN;AACD;;AAED;AACA,SAAO,eAAe,iBAAf,CAAP;AACD;;AAED;AACA,OAAO,WAAP,GAAqB,UAAC,GAAD;AAAA,SAAmB,GAAnB;AAAA,CAArB;;AAEA,OAAO,OAAP,GAAiB,MAAjB;AACA,OAAO,OAAP,CAAe,cAAf,GAAgC,cAAhC","file":"templ8.js","sourcesContent":["// @flow\n\n\"use strict\"\n\n// How we tokenise the html\nconst TAG_REGEX: RegExp = /<([^ ]+[.*]|[^>])+>|([^<]+)/g\n\n/**\n * Get well formed object of attributes from\n * and array of attribute strings pulled from the string.\n *\n * @param  {Array<string>} tokens to parse attributes from.\n * @return {Object} parsed attributes key => values\n */\nfunction get_attrs_from_tokens(tokens: Array<string>): Object {\n  const out = Object.create(null)\n\n  tokens\n    .map(part => part.trim())\n    .filter(part => part && part.length > 0)\n    .forEach((attr, index) => {\n      // Add the attributes.\n      if (index % 2 === 0)\n        out[attr] = tokens[index + 1]\n    })\n\n  return out\n}\n\nfunction style_object_from_string(styles: string): object {\n  const parts = styles.split(\";\")\n  const out = {}\n\n  parts.forEach(style => {\n    const [key, value] = style.split(\":\")\n    const styleKey = key.trim().replace(/-([a-z])/ig, (matches, letter) => letter.toUpperCase())\n    out[styleKey] = value.trim()\n  })\n\n  return out\n}\n\n/**\n * Generate an object from a tokenised piece of HTML.\n *\n * @param {string} token to parse into the tree.\n */\nfunction AST_from_token(token: string, type: string = \"VirtualText\"): AST {\n  const target: AST = {\n    type\n  }\n\n  // Get the parts.\n  const [tag, ...attrs] = token\n    // Strip off any GT/LT tokens.\n    .substring(1, token.length - (token.endsWith(\"/>\") ? 2 : 1))\n\n    // Split up the attributes.\n    .split(/(\\S+)=[\"']?((?:.(?![\"']?\\s+(?:\\S+)=|[>\"']))+.)[\"']?/g)\n\n    // Filter artifacts from the above RegExp.\n    .filter(item => item && item.trim().length > 0)\n\n  if (!tag)\n    return target\n\n  // Set the tag name.\n  if (type === \"VirtualNode\") {\n    target.tagName = tag.trim()\n    target.children = []\n  }\n\n  target.version = \"2\"\n\n  // Add any attributes.\n  if (attrs.length > 0) {\n    const tokenised_attrs = get_attrs_from_tokens(attrs)\n\n    if (tokenised_attrs.style) {\n      target.style = style_object_from_string(tokenised_attrs.style)\n      delete tokenised_attrs.style\n    }\n\n    if (Object.keys(tokenised_attrs).length > 0)\n      target.attrs = tokenised_attrs\n  }\n\n  return target\n}\n\nfunction parse_template(template: string): AST {\n  // The AST we're generating.\n  let AST: AST = {}\n  let index = 0\n\n  // Used in the loop.\n  let matches: Array<string>\n\n  // We'll use this array to track parents.\n  const ASTs = []\n\n  // Split the template into tags and closing tokens.\n  while(matches = TAG_REGEX.exec(template)) {\n    const token = matches[0]\n    const target_children = ASTs.length > 0 ? ASTs[ASTs.length - 1].children : null\n\n    // Start with a tree.\n    if (index === 0) {\n      AST = AST_from_token(token, \"VirtualNode\")\n      ASTs.push(AST)\n    }\n    // Check for text.\n    else if (!token.startsWith(\"<\") && !token.endsWith(\">\")) {\n      if (target_children && token.replace(/\\s+/g, \"\") !== \"\")\n        target_children.push({\n          type: \"VirtualText\",\n          text: token,\n          version: \"2\"\n        })\n    }\n    // If it's a tag and it's not a closing tag create a new\n    // virtual node and push the new tree into the potential\n    // parents array ASTs.\n    else if (!token.startsWith(\"</\") && !token.endsWith(\"/>\")) {\n      const new_AST = AST_from_token(token, \"VirtualNode\")\n      if (target_children)\n        target_children.push(new_AST)\n\n      ASTs.push(new_AST)\n    }\n    // It's probably a closing tag, clear the last one out\n    // of the array of generated ASTs.\n    else {\n      ASTs.pop()\n    }\n\n    // Bump the index.\n    index++\n  }\n\n  if (!AST.children || AST.children.length === 0)\n    delete AST.children\n\n  return templ8.transformer(AST)\n}\n\n/**\n * Parse a template string (interpolate it's values)\n * and generate an object representing that string\n * for virtual dom,\n *\n * @param  {Array<string>} template parts.\n * @param  {Array<string>} values to interpolate into the template parts.\n * @return {Entity} valid virtual dom element.\n */\nfunction templ8(template: Array<string>, ...values: Array<string>): AST {\n  // Compile the template.\n  const rendered_template = template.reduce((out, current, index) => {\n    out += current\n    if (values.hasOwnProperty(index))\n      out += values[index]\n\n    return out\n  }, \"\")\n\n  if (rendered_template === \"\") {\n    throw new Error(\"Cannot create a virtual DOM from an empty template/values pair. This is usually caused by having a template like ${myVar} where myVar is empty.\")\n  }\n\n  // Create the VDom.\n  return parse_template(rendered_template)\n}\n\n// Default transformer.\ntempl8.transformer = (AST: AST): AST => AST\n\nmodule.exports = templ8\nmodule.exports.parse_template = parse_template\n"]}